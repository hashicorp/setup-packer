"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const path = require("path");
const fs = require("fs");
const tempy = require("tempy");
const index_1 = require("./index");
const utils = require("./utils");
describe('LS installer', () => {
    let release;
    beforeAll(() => {
        release = new index_1.Release({
            name: 'terraform-ls',
            version: '0.25.2',
            shasums: 'terraform-ls_0.25.2_SHA256SUMS',
            shasums_signature: 'terraform-ls_0.25.2_SHA256SUMS.sig',
            shasums_signatures: ['terraform-ls_0.25.2_SHA256SUMS.72D7468F.sig', 'terraform-ls_0.25.2_SHA256SUMS.sig'],
            builds: [
                {
                    name: 'terraform-ls',
                    version: '0.25.2',
                    os: 'darwin',
                    arch: 'amd64',
                    filename: 'terraform-ls_0.25.2_darwin_amd64.zip',
                    url: 'https://releases.hashicorp.com/terraform-ls/0.25.2/terraform-ls_0.25.2_darwin_amd64.zip',
                },
            ],
        });
    });
    it('should calculate correct file sha256 sum', () => __awaiter(void 0, void 0, void 0, function* () {
        const expectedSum = '0314c6a66b059bde92c5ed0f11601c144cbd916eff6d1241b5b44e076e5888dc';
        const testPath = path.resolve(__dirname, '..', 'testFixture', 'shasumtest.txt');
        const sum = yield release.calculateFileSha256Sum(testPath);
        assert.strictEqual(sum, expectedSum);
    }));
    it('should download the correct sha256 sum', () => __awaiter(void 0, void 0, void 0, function* () {
        const expectedSum = '8629ccc47ee8d4dfe6d23efb93b293948a088a936180d07d3f2ed118f6dd64a5';
        const remoteSum = yield release.downloadSha256Sum(release.builds[0].filename);
        assert.strictEqual(remoteSum, expectedSum);
    }));
    it('should download the release', () => __awaiter(void 0, void 0, void 0, function* () {
        const build = release.getBuild('darwin', 'amd64');
        const tmpDir = tempy.directory();
        const zipFile = path.resolve(tmpDir, `terraform-ls_v${release.version}.zip`);
        yield release.download(build.url, zipFile, 'js-releases/mocha-test');
        yield release.verify(zipFile, build.filename);
        fs.rmSync(tmpDir, {
            recursive: true,
        });
    }), 20 * 1000);
});
describe('getRelease', () => {
    const name = 'vault';
    it('should return latest releases when called without a version', () => __awaiter(void 0, void 0, void 0, function* () {
        const request = jest.spyOn(utils, 'request').mockImplementation(() => __awaiter(void 0, void 0, void 0, function* () {
            return ({
                name,
                versions: {
                    '0.11.0': { name, version: '0.11.0' },
                    '1.5.0': { name, version: '1.5.0' },
                    '1.2.7': { name, version: '1.2.7' },
                },
            });
        }));
        const release = yield (0, index_1.getRelease)(name);
        expect(request).toHaveBeenCalledWith('https://releases.hashicorp.com/vault/index.json', { headers: null });
        expect(request).toHaveBeenCalledTimes(1);
        expect(release).toBeInstanceOf(index_1.Release);
        expect(release.name).toBe(name);
        expect(release.version).toBe('1.5.0');
    }));
    it('should return the matching version', () => __awaiter(void 0, void 0, void 0, function* () {
        jest.spyOn(utils, 'request').mockImplementation(() => __awaiter(void 0, void 0, void 0, function* () {
            return ({
                name,
                versions: {
                    '0.11.0': { name, version: '0.11.0' },
                    '1.2.7': { name, version: '1.2.7' },
                    '1.5.0': { name, version: '1.5.0' },
                },
            });
        }));
        const version = '1.2.7';
        const release = yield (0, index_1.getRelease)(name, version);
        expect(release).toBeInstanceOf(index_1.Release);
        expect(release.name).toBe(name);
        expect(release.version).toBe(version);
    }));
    it('should throw if no version is found', () => __awaiter(void 0, void 0, void 0, function* () {
        jest.spyOn(utils, 'request').mockImplementation(() => __awaiter(void 0, void 0, void 0, function* () {
            return ({
                name,
                versions: {},
            });
        }));
        const version = '1.2.7';
        yield expect((0, index_1.getRelease)(name, version)).rejects.toThrow('No matching version found');
    }));
    it('should filter invalid versions', () => __awaiter(void 0, void 0, void 0, function* () {
        jest.spyOn(utils, 'request').mockImplementation(() => __awaiter(void 0, void 0, void 0, function* () {
            return ({
                name,
                versions: {
                    '1.2.6.1+ent': { name, version: '1.2.6.1+ent' },
                    '1.2.7': { name, version: '1.2.7' },
                    '1.5.0': { name, version: '1.5.0' },
                    '1.6.6.1+ent': { name, version: '1.6.6.1+ent' },
                },
            });
        }));
        const release = yield (0, index_1.getRelease)(name);
        expect(release).toBeInstanceOf(index_1.Release);
        expect(release.name).toBe(name);
        expect(release.version).toBe('1.5.0');
    }));
    it('should return latest if passed an invalid version', () => __awaiter(void 0, void 0, void 0, function* () {
        jest.spyOn(utils, 'request').mockImplementation(() => __awaiter(void 0, void 0, void 0, function* () {
            return ({
                name,
                versions: {
                    '1.2.7': { name, version: '1.2.7' },
                    '1.6.0': { name, version: '1.6.0' },
                },
            });
        }));
        const release = yield (0, index_1.getRelease)(name, '1.6.6.1+ent');
        expect(release).toBeInstanceOf(index_1.Release);
        expect(release.name).toBe(name);
        expect(release.version).toBe('1.6.0');
    }));
});
//# sourceMappingURL=index.test.js.map